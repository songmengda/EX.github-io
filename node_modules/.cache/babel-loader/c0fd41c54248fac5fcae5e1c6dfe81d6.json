{"remainingRequest":"/Users/songmengda/Desktop/my/mygithub/yudi-canvas/yudi-canvas/node_modules/babel-loader/lib/index.js!/Users/songmengda/Desktop/my/mygithub/yudi-canvas/yudi-canvas/node_modules/cache-loader/dist/cjs.js??ref--0-0!/Users/songmengda/Desktop/my/mygithub/yudi-canvas/yudi-canvas/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/songmengda/Desktop/my/mygithub/yudi-canvas/yudi-canvas/src/pages/rain01.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/songmengda/Desktop/my/mygithub/yudi-canvas/yudi-canvas/src/pages/rain01.vue","mtime":1556528999786},{"path":"/Users/songmengda/Desktop/my/mygithub/yudi-canvas/yudi-canvas/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/songmengda/Desktop/my/mygithub/yudi-canvas/yudi-canvas/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/Users/songmengda/Desktop/my/mygithub/yudi-canvas/yudi-canvas/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/songmengda/Desktop/my/mygithub/yudi-canvas/yudi-canvas/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":["//\n//\n//\n//\n//\n//\n//\nimport { queryCoupon } from '@/api/service.js';\nexport default {\n  components: {},\n  data: function data() {\n    return {};\n  },\n  computed: {},\n  mounted: function mounted() {},\n  created: function created() {\n    this.$nextTick(function () {\n      //说明 画布的默认值是300 * 150\n      var can = document.getElementById('canvas'); //设置绘图环境  是2d还是3d\n\n      var cxt = can.getContext('2d'); //获取浏览器窗口的宽高\n\n      var w = can.width = window.innerWidth;\n      var h = can.height = window.innerHeight; //让画布的宽高跟随浏览器窗口的变化而变化\n\n      window.onresize = function () {\n        w = can.width = window.innerWidth;\n        h = can.height = window.innerHeight;\n      }; //设置画笔的颜色\n      // cxt.fillStyle='red';\n      //绘制矩形\n      //cxt.fillRect(0,0,100,100);//绘制的坐标点 x y   宽和高w h\n      //cxt.fill() 填充方法 （实心儿的）cxt.stroke() 触笔方法（空心的）\n      //cxt.rect(x,y,w,h) 规定矩形的路径 \n      //绘制圆形\n      //设置圆形的路径\n      //cxt.arc(250,250,50,0,Math.PI*2,false);//圆心坐标：x，y ，半径r，\n      // 从0度角绘制到360度（必须是弧度制 :Math.PI*角度/180） ，逆时针\n      //cxt.fill() //绘制一下\n      // var x=100 ,y=0\n\n      /*\n      setInterval(()=>{\n          y++\n          cxt.clearRect(0, 0, w, h);//清楚之前画布的内容\n          \n          cxt.fillRect(x,y,50,50)\n      },1000/60)\n      */\n\n      /*\n      function move(){\n          y++\n          cxt.clearRect(0, 0, w, h);//清楚之前画布的内容\n          cxt.fillRect(x,y,50,50)\n          requestAnimationFrame(move)//原生js的经动画\n      }\n      move()\n      */\n\n\n      var drops = []; //用来保存所有的雨滴实例对象\n      //创建雨滴对象\n\n      function Drop() {}\n\n      Drop.prototype = {\n        init: function init() {\n          //初始化方法（设置每个雨滴的初始属性）\n          this.x = random(0, w); //水平方向上的距离\n\n          this.y = 0; //y方向的速度值\n\n          this.vy = random(4, 5);\n          this.l = random(0.8 * h, 0.9 * h); //雨滴夏下落的高度为浏览器80%-90%的高度\n          //波纹半径\n\n          this.r = 1;\n          this.vr = 1; //半径的增大的速度\n          //判断雨滴消失的透明度\n\n          this.a = 1; //=>0\n\n          this.va = 0.96; //透明度的变化系数\n        },\n        draw: function draw() {\n          //绘制图形\n          if (this.y > this.l) {\n            //雨滴下落到指定位置 开始绘制圆形\n            cxt.beginPath(); //先初始化开始路径\n\n            cxt.arc(this.x, this.y, this.r, 0, Math.PI * 2, false);\n            cxt.strokeStyle = 'rgba(0,255,255,' + this.a + ')';\n            cxt.stroke();\n          } else {\n            cxt.fillStyle = 'rgb(0,255,255)';\n            cxt.fillRect(this.x, this.y, 2, 10);\n          }\n\n          this.updata(); //每绘制完成一次就更新一次坐标       \n        },\n        updata: function updata() {\n          //更新坐标的位置\n          if (this.y < this.l) {\n            this.y += this.vy;\n          } else {\n            //雨滴下落到达指定位置，开始画圆\n            if (this.a > 0.03) {\n              this.r += this.vr;\n\n              if (this.r > 50) {\n                this.a *= this.va;\n              }\n            } else {\n              //重新初始化雨滴数据\n              this.init();\n            }\n          }\n        } //新建一个雨滴实例化对象  这个drop拥有init和draw的方法\n        //var drop =new Drop();\n        //drop.init()//初始化\n        //drop.draw()//绘制\n\n      };\n\n      for (var i = 0; i < 30; i++) {\n        setTimeout(function () {\n          //每一个雨滴延迟200毫秒\n          var drop = new Drop();\n          drop.init();\n          drops.push(drop);\n        }, i * 300);\n      }\n\n      function move() {\n        //先绘制透明层，再绘制雨滴 雨滴就把先绘制的透明层覆盖，下一次在绘制透明层，就会把之前绘制的\n        // 雨滴覆盖  若干透明层叠加就越来越不透明了\n        cxt.fillStyle = 'rgba(0,0,0,0.1)';\n        cxt.fillRect(0, 0, w, h);\n\n        for (var i = 0; i < drops.length; i++) {\n          drops[i].draw();\n        }\n\n        requestAnimationFrame(move); //原生js的经动画 (执行递归)  \n      }\n\n      move(); //生成随机数的方法\n\n      function random(min, max) {\n        return Math.random() * (max - min) + min; //生成一个最大值到最小值之间的一个随机数\n      }\n    });\n  },\n  methods: {}\n};",{"version":3,"sources":["rain01.vue"],"names":[],"mappings":"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","sourcesContent":["<template>\n  <div>\n    <!-- canvas的width和height是他的属性，并不是单纯的css -->\n    <canvas id=\"canvas\">您的浏览器不支持canvas标签</canvas>\n  </div>\n</template>\n\n<script>\nimport { queryCoupon } from '@/api/service.js'\nexport default {\n  components: {},\n\n  data () {\n    return {\n    }\n  },\n\n  computed: {},\n\n  mounted () { },\n\n  created () {\n    this.$nextTick(function () {\n      //说明 画布的默认值是300 * 150\n      var can = document.getElementById('canvas');\n      //设置绘图环境  是2d还是3d\n      var cxt = can.getContext('2d');\n      //获取浏览器窗口的宽高\n      var w = can.width = window.innerWidth\n      var h = can.height = window.innerHeight\n      //让画布的宽高跟随浏览器窗口的变化而变化\n      window.onresize = function () {\n        w = can.width = window.innerWidth\n        h = can.height = window.innerHeight\n      }\n\n      //设置画笔的颜色\n      // cxt.fillStyle='red';\n      //绘制矩形\n      //cxt.fillRect(0,0,100,100);//绘制的坐标点 x y   宽和高w h\n      //cxt.fill() 填充方法 （实心儿的）cxt.stroke() 触笔方法（空心的）\n      //cxt.rect(x,y,w,h) 规定矩形的路径 \n      //绘制圆形\n      //设置圆形的路径\n      //cxt.arc(250,250,50,0,Math.PI*2,false);//圆心坐标：x，y ，半径r，\n      // 从0度角绘制到360度（必须是弧度制 :Math.PI*角度/180） ，逆时针\n      //cxt.fill() //绘制一下\n      // var x=100 ,y=0\n      /*\n      setInterval(()=>{\n          y++\n          cxt.clearRect(0, 0, w, h);//清楚之前画布的内容\n          \n          cxt.fillRect(x,y,50,50)\n      },1000/60)\n      */\n      /*\n      function move(){\n          y++\n          cxt.clearRect(0, 0, w, h);//清楚之前画布的内容\n          cxt.fillRect(x,y,50,50)\n          requestAnimationFrame(move)//原生js的经动画\n      }\n      move()\n      */\n\n\n      var drops = []//用来保存所有的雨滴实例对象\n\n      //创建雨滴对象\n      function Drop () { }\n      Drop.prototype = {\n        init: function () {//初始化方法（设置每个雨滴的初始属性）\n          this.x = random(0, w)   //水平方向上的距离\n          this.y = 0\n          //y方向的速度值\n          this.vy = random(4, 5)\n          this.l = random(0.8 * h, 0.9 * h)//雨滴夏下落的高度为浏览器80%-90%的高度\n          //波纹半径\n          this.r = 1;\n          this.vr = 1;//半径的增大的速度\n\n          //判断雨滴消失的透明度\n          this.a = 1  //=>0\n          this.va = 0.96  //透明度的变化系数\n        },\n        draw: function () {//绘制图形\n\n          if (this.y > this.l) {//雨滴下落到指定位置 开始绘制圆形\n\n            cxt.beginPath();//先初始化开始路径\n\n            cxt.arc(this.x, this.y, this.r, 0, Math.PI * 2, false)\n\n            cxt.strokeStyle = 'rgba(0,255,255,' + this.a + ')';\n\n            cxt.stroke();\n\n          } else {\n            cxt.fillStyle = 'rgb(0,255,255)';\n            cxt.fillRect(this.x, this.y, 2, 10);\n          }\n          this.updata()//每绘制完成一次就更新一次坐标       \n\n        },\n        updata: function () { //更新坐标的位置\n          if (this.y < this.l) {\n            this.y += this.vy\n          } else { //雨滴下落到达指定位置，开始画圆\n            if (this.a > 0.03) {\n              this.r += this.vr\n              if (this.r > 50) {\n                this.a *= this.va\n              }\n            } else {\n              //重新初始化雨滴数据\n              this.init()\n            }\n          }\n        }\n      }\n\n      //新建一个雨滴实例化对象  这个drop拥有init和draw的方法\n      //var drop =new Drop();\n      //drop.init()//初始化\n      //drop.draw()//绘制\n      for (var i = 0; i < 30; i++) {\n        setTimeout(() => { //每一个雨滴延迟200毫秒\n          var drop = new Drop();\n          drop.init();\n          drops.push(drop);\n        }, i * 300);\n      }\n\n      function move () {\n        //先绘制透明层，再绘制雨滴 雨滴就把先绘制的透明层覆盖，下一次在绘制透明层，就会把之前绘制的\n        // 雨滴覆盖  若干透明层叠加就越来越不透明了\n        cxt.fillStyle = 'rgba(0,0,0,0.1)'\n        cxt.fillRect(0, 0, w, h)\n        for (var i = 0; i < drops.length; i++) {\n          drops[i].draw()\n        }\n        requestAnimationFrame(move);//原生js的经动画 (执行递归)  \n      }\n      move()\n\n      //生成随机数的方法\n      function random (min, max) {\n        return Math.random() * (max - min) + min;//生成一个最大值到最小值之间的一个随机数\n      }\n    })\n  },\n\n  methods: {}\n\n}\n\n</script>\n<style lang=\"less\"  rel=\"stylesheet/less\" scope type=\"text/less\">\n@r: 100;\n* {\n  padding: 0;\n  margin: 0;\n}\nhtml,\nbody {\n  height: 100%;\n  overflow: hidden;\n}\n#canvas {\n  width: 100%;\n  height: 100%;\n  background: #000;\n  display: block;\n}\n</style>"],"sourceRoot":"src/pages"}]}